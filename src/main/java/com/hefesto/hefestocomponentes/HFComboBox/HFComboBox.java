/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.hefesto.hefestocomponentes.HFComboBox;

import com.hefesto.hefestocomponentes.HFBaloon.HFBallonUtil;
import com.hefesto.hefestocomponentes.HFUtils.Messages;
import java.awt.Color;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import static java.awt.image.ImageObserver.HEIGHT;
import static java.awt.image.ImageObserver.WIDTH;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.swing.border.Border;
import javax.swing.border.LineBorder;
import javax.swing.text.JTextComponent;
import net.java.balloontip.BalloonTip;
import net.java.balloontip.styles.RoundedBalloonStyle;
import net.java.balloontip.utils.TimingUtils;
import org.jdesktop.swingx.autocomplete.AutoCompleteDecorator;

/**
 *
 * @author Flavio
 */
public class HFComboBox extends javax.swing.JComboBox {

    /**
     * Creates new form HFComboBox
     */
    private Boolean autoComplete = false;
    private Boolean pesquisavel = false;
    private JTextComponent Edit;
    private String[] nomes;
    private String[] nomesOriginal;
    private Object[] objetos;
    private Object[] originalObjetos;
    RoundedBalloonStyle ballonStyle = new RoundedBalloonStyle(WIDTH, HEIGHT, Color.LIGHT_GRAY, Color.DARK_GRAY);
    Border borda;

    public HFComboBox() {
        initComponents();
        borda = this.getBorder();
        setRenderer(new HFComboRender());
        Edit = (JTextComponent) getEditor().getEditorComponent();
        Edit.addFocusListener(new FocusAdapter() {
            @Override
            public void focusLost(FocusEvent e) {
                if (isPesquisavel()) {
                    if (getObjetoSelecionado() == null) {
                        if (getItemCount() == 1) {
                            setSelectedIndex(0);
                        }
                        if (getSelectedIndex() != 0) {
                            pesquisaCombo("");
                            setSelectedIndex(0);
                        }
                        Edit.select(0, 0);
                    }
                }
            }

            @Override
            public void focusGained(FocusEvent e) {
                if (isPesquisavel()) {
                    Edit.selectAll();
                }
            }

        });
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                formFocusGained(evt);
            }
        });
    }// </editor-fold>//GEN-END:initComponents

    private void formFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_formFocusGained
        this.setBorder(borda);
    }//GEN-LAST:event_formFocusGained


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    public Boolean isAutoComplete() {
        return autoComplete;
    }

    /**
     * marca o combo para autoCompletar
     *
     * @param autoComplete
     */
    public void setAutoComplete(Boolean autoComplete) {
        if (autoComplete) {
            AutoCompleteDecorator.decorate(this);
        }
        this.autoComplete = autoComplete;
    }

    /**
     * Adiciona Itens no Combo
     *
     * @param itens
     */
    public void adicionarItens(List<?> itens) {
        adicionarItensPrivate(itens, Messages.getMessage("combo.selecione.valor"));
    }

    private void adicionarItensPrivate(List<?> itens, String first) {
        if (!itens.isEmpty()) {
            nomes = (String[]) itens.get(0);
            objetos = (Object[]) itens.get(1);
            if (objetos.length > 0) {
                this.removeAllItems();
                this.addItem(first);
                for (String nome : nomes) {
                    this.addItem(nome);
                }
            } else {
                this.addItem(Messages.getMessage("combo.sem.valor"));
            }
        }
    }

    public Object getObjetoSelecionado() {
        return getObjetoNoIndice(this.getSelectedIndex() - 1);
    }

    public Object getObjetoNoIndice(int idx) {
        if (idx < 0) {
            return null;
        }
        if (objetos.length == 0) {
            return null;
        }
        if (objetos != null) {
            if (idx <= objetos.length) {
                return objetos[idx];
            } else {
                BalloonTip balloon = new BalloonTip(HFComboBox.this, Messages.getMessage("valor.combo.invalido"), ballonStyle, false);
                TimingUtils.showTimedBalloon(balloon, 3000);
                this.setBorder(new LineBorder(Color.red));
                return null;
            }
        }

        BalloonTip balloon = new BalloonTip(HFComboBox.this, Messages.getMessage("valor.objetos.nullo"), ballonStyle, false);
        TimingUtils.showTimedBalloon(balloon, 3000);
        this.setBorder(new LineBorder(Color.red));
        return null;
    }

    /**
     * Define se o combo pode ser pesquisavel
     *
     * @param pesquisavel true para permitir a pesquisa.
     * @see #pesquisaCombo(java.lang.String)
     * @since 2.3
     */
    public void setPesquisavel(Boolean pesquisavel) {
        this.pesquisavel = pesquisavel;
        this.setEditable(pesquisavel);
        if (pesquisavel) {
            this.getEdit().addKeyListener(new KeyAdapter() {
                @Override
                public void keyReleased(KeyEvent e) {
                    if (validaPesquisa(e)) {
                        String pesquisa = getEdit().getText();
                        pesquisaCombo(pesquisa);
                        getEdit().setText(pesquisa);
                        getEdit().setCaretPosition(pesquisa.length());
                    }
                }
            });
        }
    }

    /**
     * Valida os eventos do teclado para realizar o minemnico
     *
     * @param e
     * @return true caso o compoenente possa ser pesquisado
     */
    public Boolean validaPesquisa(KeyEvent e) {
        return ((e.getKeyCode() != KeyEvent.VK_UP)
                && (e.getKeyCode() != KeyEvent.VK_DOWN)
                && (e.getKeyCode() != KeyEvent.VK_LEFT)
                && (e.getKeyCode() != KeyEvent.VK_RIGHT)
                && (e.getKeyCode() != KeyEvent.VK_ENTER)
                && (e.getKeyCode() != KeyEvent.VK_SHIFT)
                && (e.getKeyCode() != KeyEvent.VK_HOME)
                && (e.getKeyCode() != KeyEvent.VK_CONTROL)
                && (e.getKeyCode() != KeyEvent.VK_END)
                && (e.getKeyCode() != KeyEvent.VK_F2)
                && (e.getKeyCode() != KeyEvent.VK_F6)
                && (e.getKeyCode() != KeyEvent.VK_F4)
                && (e.getKeyCode() != KeyEvent.VK_F10)
                && this.isEditable);
    }

    /**
     * Realiza a pesquisa nos elementos do combo.
     *
     * @param pesquisa
     */
    public void pesquisaCombo(String pesquisa) {
        long inicio = System.currentTimeMillis();
        List lista = new ArrayList();
        List<String> noms = new ArrayList<String>();
        try {

            if (originalObjetos == null) {
                originalObjetos = objetos;
                nomesOriginal = nomes;
            }
            if (nomesOriginal == null) {
                nomesOriginal = nomes;
            }
            if (!pesquisa.isEmpty()) {
                int i = 0;
                int found = 0;
                for (Object o : originalObjetos == null ? objetos : originalObjetos) {
                    /**
                     * Versao 2.4
                     */
                    if (found > 50) {
                        break;
                    }
                    if (o != null) {
                        Field[] fields = o.getClass().getDeclaredFields();
                        for (Field f : fields) {
                            if (!f.getName().toUpperCase().contains("COLLECTION")) {
                                f.setAccessible(true);
                                try {
                                    Object value = f.get(o);
                                    //Ignora coleções e so pega os valores do tipo String, Integer, Long e long
                                    if (!(value instanceof Collection)
                                            && ((value instanceof String)
                                            || (value instanceof Integer)
                                            || value instanceof Long)) {
                                        String strValue = value + "";
                                        if (strValue.toUpperCase().contains(pesquisa.toUpperCase())) {
                                            if (!lista.contains(o)) {
                                                noms.add(nomesOriginal[i] != null ? nomesOriginal[i] + "" : null);
                                                lista.add(o);
                                                found++;

                                            }
                                        }
                                        strValue = null;
                                    }
                                    value = null;
                                } catch (IllegalArgumentException ex) {
                                    ex.printStackTrace();
                                } catch (IllegalAccessException ex) {
                                    ex.printStackTrace();
                                }
                            }
                        }

                        //Pesquisa nos nomes dentro do combo
                        if (String.valueOf(nomesOriginal[i]).toUpperCase().contains(pesquisa.toUpperCase())) {
                            if (!lista.contains(o)) {
                                noms.add((nomesOriginal[i] != null ? nomesOriginal[i] + "" : null));
                                lista.add(o);
                                found++;
                            }
                        }
                    }
                    i++;
                }
                if (!lista.isEmpty()) {
                    String[] n = new String[lista.size()];
                    for (i = 0; i < lista.size(); i++) {
                        n[i] = noms.get(i);
                    }
                    List<Object[]> list = new ArrayList<Object[]>();
                    list.add(n);
                    list.add(lista.toArray(new Object[]{}));
                    adicionarItens(list);

                } else {
                    List<Object[]> list = new ArrayList<Object[]>();
                    list.add(new String[]{});
                    list.add(new Object[]{});
                    adicionarItensPrivate(list, Messages.getMessage("valor.nao.encontrado"));

                }
            } else {
                List<Object[]> list = new ArrayList<Object[]>();
                lista.add(nomesOriginal);
                lista.add(originalObjetos);
                adicionarItens(list);
            }
            this.setSelectedIndex(-1);
            //System.out.println("Busca de " + lista.size() + " realizada em " + (System.currentTimeMillis() - inicio) + "ms");
            this.setPopupVisible(this.isShowing());

        } finally {
            lista = null;
            noms = null;
            pesquisa = null;

        }
    }

    /**
     * O componente editor do Combobox
     *
     * @return o compoenente editor desse campo
     */
    public JTextComponent getEdit() {
        return Edit;
    }

    /**
     *  * O componente editor do Combobox
     *
     * @param Edit
     */
    public void setEdit(JTextComponent Edit) {
        this.Edit = Edit;
    }

    private boolean isPesquisavel() {
        return pesquisavel;
    }

    /**
     * Verifica se o combo esta com um valor valido selecionado.
     *
     * @return
     */
    public boolean valida() {
        if (this.getSelectedIndex() == 0) {
            this.setBorder(new LineBorder(Color.red));
            HFBallonUtil.showTimedBallon(this, Messages.getMessage("valor.selecionado.invalido"), null);
            return false;
        }
        this.setBorder(borda);
        return true;
    }

    /**
     * Método que Limpa o Componente
     *
     * @since 2.8
     */
    public void LimparComponente() {
        if (isPesquisavel()) {
            pesquisaCombo("");
        }
        setObjetoSelecionado(null);
        setPopupVisible(false);
    }

    public void setObjetoSelecionado(Object object) {
        if (object == null) {
            this.setSelectedIndex(0);
        } else {
            Boolean achou = false;
            for (int i = 0; i < objetos.length; i++) {
                if (objetos[i].equals(object)) {
                    achou = true;
                    this.setSelectedIndex(i + 1);
                    break;
                }
            }
            if (!achou) {
                this.setSelectedIndex(0);
            }
        }
    }

    @Override
    public synchronized void addFocusListener(FocusListener l) {
        super.addFocusListener(l);
        this.getEditor().getEditorComponent().addFocusListener(l);
    }

}
